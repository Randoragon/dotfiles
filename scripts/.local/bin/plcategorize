#!/bin/sh

# Edit currently playing track's membership in playlists.
# This script is an interactive alternative to pladd_select.
#
# Dependencies:
# - mpd, mpc
# - rg (ripgrep)
# - taptempo (https://taptempo.tuxfamily.org)
# - id3ted
# - ffmpeg
# - sox
# - awk

musicdir=~/Music
pldir="$musicdir"/Playlists
mappings="${XDG_CONFIG_HOME:-$HOME/.config}/plcategorize-mappings.tsv"
mpc_fmt='%file%%artist%%title%%album%%time%'
tmp="$(mktemp -t plcategorize.XXXXX)" # aux buffer

cleanup () {
    rm -f -- "$tmp"
    exit 0
}
trap cleanup INT QUIT TERM EXIT

[ ! -r "$mappings" ] && {
    printf 'Failed to read %s.\n' "$mappings" >&2
    exit 1
}

playlists="$(find "$pldir" -maxdepth 1 -type f -regex '.*/[_!@#%][^/]*\.m3u' -writable \! -name '#Fair Use.m3u' -exec basename -- '{}' \; | sort -k1.1,1.1r)"
last_termw=
last_change=

eprint () {
    tput sgr0 >&2
    printf '  ' >&2
    tput setaf 15 setab 1 >&2
    printf "$@" >&2
    tput sgr0 >&2
}

# Detect mapping collisions
duplicates="$(cut -d'	' -f2 -- "$mappings" | sort | uniq -d)"
[ -n "$duplicates" ] && {
    eprint "Prefix collisions: "
    for dupe in ${duplicates% *}; do
        eprint "$dupe"
    done
    eprint '\n'
    exit 2
}

getprefix () {
    match="$(rg -F -- "$1	" "$mappings")"
    echo "${match##*	}"
}

getplaylist () {
    match="$(cut -d'	' -f2 -- "$mappings" | rg -Fn -- "$1")"
    [ -z "$match" ] && return
    sed -n "${match%%:*}s/	.*//p" "$mappings"
}

main () {
    print_info () {
        # Print track information
        if [ -z "$file" ]; then
            tput sgr0
            printf '  Nothing is selected, press return to refresh.\n'
            return 1
        else
            tput sgr0 bold
            printf '  "%s"' "$title"
            tput setaf 6
            printf ' [%s]\n' "$length"
            tput setaf 2
            printf '  by '
            tput setaf 3
            printf '%s\n' "$artist"
            [ -n "$album" ] && {
                tput setaf 2
                printf '  in '
                tput setaf 6
                printf '%s\n' "$album"
            }
            tput sgr0
        fi
    }

    # Parse menu inputs
    [ "$1" = q ] && echo Bye. && exit
    [ "$1" =  ] || [ -z "$data" ] && {
        data="$(mpc current -f "$mpc_fmt")"
        file="$(echo "$data" | cut -d -f1)"
        artist="$(echo "$data" | cut -d -f2)"
        title="$(echo "$data" | cut -d -f3)"
        album="$(echo "$data" | cut -d -f4)"
        length="$(echo "$data" | cut -d -f5)"
        [ -n "$file" ] && [ ! -f "$musicdir/$file" ] && eprint "'%s' not found.\n" "$musicdir/$file" && return
        set -- ''
    }

    # BPM tool
    [ "$1" = , ] && {
        [ -z "$file" ] && echo 'The bpm tool requires a track to be selected.' && return
        # Print header
        clear
        tput setab 15 setaf 0 bold
        printf ' plcategorize > bpm '
        tput sgr0
        printf ' %sq%s skip'   "$(tput bold setaf 4)" "$(tput sgr0)"
        printf '\n\n'
        print_info || { eprint 'error: no selection' && return; }

        bpm_tool () {
            tag="$1"
            bpm=
            printf '\n  %s %s %s\n' "$(tput bold setab 24)" "$tag" "$(tput sgr0)"
            existing="$(echo "$id3" | sed -n "s/^TXXX: \[$tag\]: //p")"
            [ -n "$existing" ] && printf '    Found tag: %s\n' "$(tput bold)$existing$(tput sgr0)"
            printf '    Input %s or leave empty for taptempo...\n  > ' "$tag"
            read -r ans
            [ "$ans" = q ] && return
            [ -n "$ans" ] && bpm=$((ans))
            [ -z "$bpm" ] && {
                :>"$tmp"
                tput setaf 7
                taptempo -r 3 -s 16 | tee "$tmp"
                tput sgr0
                bpm="$(rg -o '[0-9]+' "$tmp" | tail -n1)"
                printf '    Last reading: %s\n    Leave empty to accept or overwrite with input.\n  > ' "$(tput bold)$bpm$(tput sgr0)"
                read -r ans
                [ "$ans" = q ] && return
                [ -n "$ans" ] && bpm="$ans"
                bpm=$((bpm))
            }
            id3ted --TXXX $bpm:"$tag" "$musicdir/$file"
            printf '    Wrote %s as %s.\n' "$(tput bold)$bpm$(tput sgr0)" "$tag"
        }

        bpm_tool bpm_begin
        bpm_tool bpm_end
        printf '\n  All done. Press return to continue.\n> '
        read -r _
        set -- ''
    }

    # Gain tool
    [ "$1" = . ] && {
        [ -z "$file" ] && echo 'The gain tool requires a track to be selected.' && return
        # Print header
        clear
        tput setab 15 setaf 0 bold
        printf ' plcategorize > gain '
        tput sgr0
        printf ' %sq%s back'   "$(tput bold setaf 4)" "$(tput sgr0)"
        printf '\n\n'
        print_info || { eprint 'error: no selection' && return; }

        # Convert length to seconds and get 10%
        length_="$length"
        seconds=0
        multi=1
        while [ -n "$length_" ]; do
            num="$(echo "$length_" | sed 's/.*:0*//')"
            seconds=$(( seconds + (multi * num) ))
            _length_="${length_%:*}"
            [ "$length_" != "$_length_" ] && length_="$_length_" || length_=
            multi=$(( multi * 60 ))
        done
        s20="$(echo | awk '{ printf "%g", '$seconds' / 5 }')"
        printf '\n  Duration:  %s = %ss (relevant: %ss)\n\n' "$length" $seconds "$(tput bold)$s20$(tput sgr0)"

        gain_tool () {
            ffmpeg_flag="$1"
            ffmpeg_time="$2"
            tag="$3"
            printf '  %s %s %s\n' "$(tput bold setab 90)" "$tag" "$(tput sgr0)"
            existing="$(echo "$id3" | sed -n "s/^TXXX: \[$tag\]: //p")"
            [ -n "$existing" ] && printf '    Found tag:     %s\n' "$(tput bold setaf 3)$existing$(tput sgr0)"
            ffmpeg -loglevel fatal -y "$ffmpeg_flag" "$ffmpeg_time" -i "$musicdir/$file" -f "${file##*.}" -c copy "$tmp" || {
                eprint '    ffmpeg failed with status %s.\n' $?
                return
            }
            gain="$(sox -t "${file##*.}" "$tmp" -n stat 2>&1 | sed -n 's/^Volume adjustment:\s*//p')"
            [ "$gain" != "${gain#-}" ] && gain="${gain#-}" || gain="-$gain"
            printf '    Computed gain: %s\n' "$(tput bold setaf 3)$gain$(tput sgr0)"
            [ "$gain" = "$existing" ] && printf '    No difference, skip.\n\n' && return
            printf '    Proceed? [Y/n] '
            read -r ans
            [ -z "$ans" ] || [ "$ans" = y ] || [ "$ans" = Y ] && {
                id3ted --TXXX "$gain":"$tag" "$musicdir/$file"
                printf '    Wrote %s as %s.\n\n' "$(tput bold setaf 3)$gain$(tput sgr0)" "$tag"
            }
        }

        gain_tool -t "$s20" gain_begin
        gain_tool -sseof "-$s20" gain_end
        printf '  All done. Press return to continue.\n> '
        read -r _
        set -- ''
    }

    # Print header
    clear
    tput setab 15 setaf 0 bold
    printf ' plcategorize '
    tput sgr0
    printf ' %sq%s exit  '   "$(tput bold setaf 4)" "$(tput sgr0)"
    printf '%sESC%s fetch  ' "$(tput bold setaf 4)" "$(tput sgr0)"
    id3="$(id3ted -l "$musicdir/$file" 2>/dev/null)"
    echo "$id3" | rg -Fq 'TXXX: [bpm_begin]: ' && \
        echo "$id3" | rg -Fq 'TXXX: [bpm_end]: ' && col=2 || col=1
    printf '%s,%s bpm  '     "$(tput bold setaf 4)" "$(tput setaf "$col")"
    echo "$id3" | rg -Fq 'TXXX: [gain_begin]: ' && \
        echo "$id3" | rg -Fq 'TXXX: [gain_end]: ' && col=2 || col=1
    printf '%s.%s gain\n\n'  "$(tput bold setaf 4)" "$(tput setaf "$col")"
    tput sgr0

    # Parse user input
    [ -n "$1" ] && {
        left="$1"
        while [ -n "$left" ]; do
            prefix="${left%"${left#?}"}"
            left="${left#?}"
            playlist="$(getplaylist "$prefix")"
            [ -z "$playlist" ] && {
                eprint 'Missing playlist for prefix: %s\n' "$prefix"
                continue
            }
            plfile="$pldir/$playlist.m3u"
            [ ! -f "$plfile" ] && {
                eprint 'No such file: "%s"\n' "$plfile"
                continue
            }
            :>"$tmp"
            rg -Fn -- "$file" "$plfile" | cut -d: -f1 >"$tmp"
            if [ -s "$tmp" ]; then
                while read -r linenum; do
                    sed -i "$linenum"d "$plfile"
                done <"$tmp"
            else
                printf '%s\n' "$file" >>"$plfile"
            fi
            sed -i '/^$/d' "$plfile"
        done
    }

    print_info || return

    # Print last non-empty line input by user
    [ -n "$1" ] && last_change="$1"
    tput sgr0 setaf 7
    printf '\n  %s\n' "$last_change"

    # Recalculate column layout
    termw="$(tput cols)"
    [ "$termw" != "$last_termw" ] && {
        printf 0 >"$tmp"
        echo "$playlists" | while read -r plname; do
            w="$(printf '%s' "${plname%.m3u}" | wc -m)"
            [ "$w" -gt "$(cat -- "$tmp")" ] && printf '%s' "$w" >"$tmp"
        done
        entryw="$(cat -- "$tmp")"
        entrycols="$(( (termw - 2) / (entryw + 4) ))"
        [ "$entrycols" -lt 1 ] && entrycols=1
        [ "$entrycols" -gt 4 ] && entrycols=4
        last_termw="$termw"
    }

    # Print playlists state
    i=0
    lastgroup=
    :>"$tmp"
    echo "$playlists" | while read -r plname; do
        plfile="$pldir/$plname"
        prefix="$(getprefix "${plname%.m3u}")"
        group="${plname%"${plname#?}"}"
        [ -z "$prefix" ] && eprint 'Missing prefix for playlist "%s"\n' "$plname"
        [ "$group" != "$lastgroup" ] && {
            cat -- "$tmp"
            :>"$tmp"
            if [ $i -eq 0 ]; then printf '\n'; else printf '\n\n'; fi
            lastgroup="$group"
            i=0
        }
        tput bold setaf 4 >>"$tmp"
        printf '  %s ' "$prefix" >>"$tmp"
        if rg -Fq -- "$file" "$plfile"; then
            tput setaf 10 >>"$tmp"
        else
            tput sgr0 setaf 9 >>"$tmp"
        fi
        printf "%-${entryw}s" "${plname%.m3u}" >>"$tmp"
        i=$((i + 1))
        [ "$((i % entrycols))" -eq 0 ] || [ "$group" != "$lastgroup" ] && {
            cat -- "$tmp"
            :>"$tmp"
            printf '\n'
            i=0
        }
    done
    [ -s "$tmp" ] && {
        cat -- "$tmp"
        printf '\n'
    }

    # Show prompt
    tput sgr0
    printf '\n> '
}

file=
data=
main
while read -r line; do
    main "$line"
done
