#!/bin/sh

# Wrapper script for storing plain-text, markup, encrypted notes.
# See "note -h" for more details.
#
# Dependencies:
# - gpg, sha1sum
# - dmenu, fzf
# - md2html (md4c)
# - groff (+mom macros)
# - neatroff (+ms, mm, rnd macros)
# - surf (html viewing)
# - env: $PDF_READER (fallback to zathura)
# - ntmake (my script for quick neatroff compilation)
# - git
# - tar
# - asciidoctor, asciidoctor-diagram (for adoc support)
#
# For neatroff rnd macros see https://github.com/randoragon/tmac-rnd

# CONFIG
notedir="${XDG_DATA_HOME:-~/.local/share}/notes"
gpgid="$notedir/.gpg-id"
nl='
'

help () {
    printf "\
Usage:
    note [OPTIONS] [NAME]

    Without the NAME argument, note will let you select a note for
    viewing with either dmenu or fzf.
    To create a new note, pass the NAME argument (with extension).

Options:
    -e, --edit
        Open note for editing instead of viewing. This implies that
        the note already exists (NAME cannot be passed).

    -t, --textonly
        View or output any markup note as plain text.

    -o FILE, --output FILE
        Output note to file, or - for standard output. This option
        is mutually exclusive with --edit and creating new notes.

    -h, --help
        Display this help text.

    --dmenu, --fzf
        Force the use of dmenu or fzf. By default, dmenu will be
        used if the stdin descriptor is not open (test ! -t 0)
        and fzf will be used otherwise. However, this test is not
        foolproof, and so you can force either dmenu or fzf with
        these options, if you need. They are mutually exclusive.

NAME Extensions:
    *.txt
        Plain text. If no extension in NAME is present, \".txt\"
        will be appended automatically.

    *.md
        Markdown

    *.adoc
        Asciidoc. See https://asciidoc.org/

    *.rnd
        Neatroff + rnd macros
        See https://github.com/randoragon/tmac-rnd

    *.mm
        Neatroff + mm macros

    *.ms
        Neatroff + ms macros

    *.mom
        groff + mom macros

String Substitutions:
    Inside a note in any format, the following strings will be
    substituted before compilation:

        NOTE_MTIME - last modification time, e.g. 'Tue 2021-08-10 14:20 CEST'
"
}

# Credit: https://stackoverflow.com/a/545413/10792539
dir_cksum () {
    find "$1" -type f -print0 | sort -z | xargs -0 cat | sha1sum
}

# extract <archive> <dir>
# Decrypts and extracts an archive into dir
extract () {
    tmp="$(mktemp --tmpdir note.XXXXX)"
    gpg --yes --quiet --output "$tmp" --decrypt -- "$1"
    tar -xzf "$tmp" -C "$2"
    shred -u -- "$tmp"
}

# archive <basedir> <archive> <gpuid>
# The opposite of extract, requires gpgid for encryption
# basedir is the root directory of the archive
# dir must be the NAME (not path) of a directory within basedir
archive () {
    tmp="$(mktemp --tmpdir note.XXXXX)"
    tar -C "$1" -czf "$tmp" -- NOTE
    gpg --yes --quiet --output "$2" --encrypt --recipient "$3" -- "$tmp"
    shred -u -- "$tmp"
}

# strsub <source> <file>
# Does in-place string substitution, as described in --help.
# source is the file that will be stat'ted for information
# file is the file that will be modified with substitutions
strsub () {
    # Update modified time according to git data
    fpath="$(realpath --relative-to "$notedir" -- "$1")"
    epoch="$(git -C "$notedir" log -1 --format='%at' -- "$fpath")"
    touch -mct "$(date -d "@$epoch" '+%Y%m%d%H%M.%S')" -- "$1"

    mtime="$(date -d "@$(stat -c %Y -- "$1")" +'%a %Y-%m-%d %H:%M %Z')"
    sed -i -e "s/NOTE_MTIME/$mtime/g" "$2"
}

# edit <archive>
# archive - path to the note archive file, relative to $notedir
edit () {
    [ ! -r "$gpgid" ] && echo "note: .gpg-id file not found, aborting." >&2 && exit 3
    tmpd="$(mktemp --tmpdir -d note.XXXXX)"
    extract "$notedir/$1" "$tmpd"
    note="$(basename -- "$1")"

    # Determine filetype
    target="$tmpd/NOTE/NOTE.txt"
    [ ! -f "$target" ] && target="$tmpd/NOTE/NOTE.md"
    [ ! -f "$target" ] && target="$tmpd/NOTE/NOTE.adoc"
    [ ! -f "$target" ] && target="$tmpd/NOTE/NOTE.rnd"
    [ ! -f "$target" ] && target="$tmpd/NOTE/NOTE.ms"
    [ ! -f "$target" ] && target="$tmpd/NOTE/NOTE.mm"
    [ ! -f "$target" ] && target="$tmpd/NOTE/NOTE.mom"
    [ ! -f "$target" ] && echo "note: NOTE file not found within the archive" >&2 && exit 4

    # Customizable setup for every file type.
    # The files variable holds a string of filenames to open.
    files="$target"
    case ".${target##*.}" in
        .adoc) files="$files${nl}$tmpd/NOTE/docinfo.html" ;;
    esac

    sum="$(dir_cksum "$tmpd/NOTE")"
    if [ -z "$interactive" ]; then
        echo "$files" | xargs alacritty -e "$EDITOR" "+cd $tmpd/NOTE" --
    else
        echo "$files " | xargs "$EDITOR" "+cd $tmpd/NOTE" --
    fi
    if [ "$(dir_cksum "$tmpd/NOTE")" = "$sum" ]; then
        echo "No changes were made, skipping."
    else
        archive "$tmpd" "$notedir/$1" "$(cat -- "$gpgid")"
        git -C "$notedir" add "$1"
        git -C "$notedir" commit -o "$1" -m "Edit $1"
    fi
    find "$tmpd" -type f -exec shred -x '{}' \;
    rm -r -- "$tmpd"
}

# view <archive>
# archive - path to the note archive file, relative to $notedir
view () {
    tmpd="$(mktemp --tmpdir -d note.XXXXX)"
    extract "$notedir/$1" "$tmpd"
    note="$(basename -- "$1")"

    # Determine filetype
    target="$tmpd/NOTE/NOTE.txt"
    fmt=txt
    [ ! -f "$target" ] && target="$tmpd/NOTE/NOTE.md"   && fmt=md
    [ ! -f "$target" ] && target="$tmpd/NOTE/NOTE.adoc" && fmt=adoc
    [ ! -f "$target" ] && target="$tmpd/NOTE/NOTE.rnd"  && fmt=rnd
    [ ! -f "$target" ] && target="$tmpd/NOTE/NOTE.ms"   && fmt=ms
    [ ! -f "$target" ] && target="$tmpd/NOTE/NOTE.mm"   && fmt=mm
    [ ! -f "$target" ] && target="$tmpd/NOTE/NOTE.mom"  && fmt=mom
    [ ! -f "$target" ] && echo "note: NOTE file not found within the archive" >&2 && exit 4
    [ -n "$textonly" ] && fmt=txt

    # Perform string substitutions, update access time
    strsub "$notedir/$1" "$target"
    touch -ac "$notedir/$1"

    case "$fmt" in
        txt)
            if [ -z "$interactive" ]; then
                alacritty -e "$PAGER" -- "$target"
            else
                "$PAGER" -- "$target"
            fi
            ;;
        md)
            tmp="$(mktemp -p "$tmpd/NOTE" "note.XXXXX.html")"
            printf "%s" "$HTML_MD_STYLE" >"$tmp"
            md2html --github -- "$target" >>"$tmp"
            [ -s "$tmp" ] && surf -- file://"$tmp"
            ;;
        adoc)
            tmp="$(mktemp -p "$tmpd/NOTE" "note.XXXXX.html")"
            asciidoctor $ASCIIDOCTOR_OPTS -o "$tmp" -- "$target"
            [ -s "$tmp" ] && surf -- file://"$tmp"
            ;;
        rnd)
            ntmake "$target" -mrnd | "${PDF_READER:-zathura}" -
            ;;
        ms)
            ntmake "$target" -ms | "${PDF_READER:-zathura}" -
            ;;
        mm)
            ntmake "$target" -mm | "${PDF_READER:-zathura}" -
            ;;
        mom)
            pdfmom -k -e -p -t "$target" | "${PDF_READER:-zathura}" -
            ;;
        *)
            printf "note: unknown note format \"%s\"\n" "$fmt" >&2
    esac
    find "$tmpd" -type f -exec shred -x '{}' \;
    rm -rf -- "$tmpd"
}

# create <note> <ext>
# note is a path of a new note relative to notedir
# ext is the target NOTE file extension
create () {
    tmpd="$(mktemp --tmpdir -d note.XXXXX)"
    fname="$(basename -- "$1")"
    mkdir -p -- "$tmpd/NOTE"
    target="$tmpd/NOTE/NOTE$2"

    # Customizable setup for every file type.
    # The files variable holds a string of filenames to open.
    :>"$target"
    files="$target"
    case "$2" in
        .adoc)
            docinfo="$tmpd/NOTE/docinfo.html"
            printf '=\n:docinfo: shared\n' >"$target"
            printf '<style>\n</style>' >"$docinfo"
            files="$files$nl$docinfo"
            ;;
    esac

    sum="$(dir_cksum "$tmpd/NOTE")"
    if [ -z "$interactive" ]; then
        echo "$files" | xargs alacritty -e $EDITOR "+cd $tmpd/NOTE" --
    else
        echo "$files" | xargs $EDITOR "+cd $tmpd/NOTE" --
    fi
    if [ "$(dir_cksum "$tmpd/NOTE")" = "$sum" ]; then
        echo "Note directory unchanged, cancelling."
    else
        mkdir -p -- "$notedir/$(dirname -- "$1")"
        archive "$tmpd" "$notedir/$1" "$(cat -- "$gpgid")"
        git -C "$notedir" add "$1"
        git -C "$notedir" commit -o "$1" -m "Create $1"
    fi
    find "$tmpd" -type f -exec shred -x '{}' \;
    rm -r -- "$tmpd"
}

# output <archive> <filename>
# archive -  path to the note archive file, relative to $notedir
# filename - path to the file to export to, or - for stdout
output () {
    tmpd="$(mktemp --tmpdir -d note.XXXXX)"
    extract "$notedir/$1" "$tmpd"
    note="$(basename -- "$1")"
    output="$2"
    stdout=
    [ "$output" = - ] && stdout=1

    # Determine filetype
    target="$tmpd/NOTE/NOTE.txt"
    fmt=txt
    [ ! -f "$target" ] && target="$tmpd/NOTE/NOTE.md"   && fmt=md
    [ ! -f "$target" ] && target="$tmpd/NOTE/NOTE.adoc" && fmt=adoc
    [ ! -f "$target" ] && target="$tmpd/NOTE/NOTE.rnd"  && fmt=rnd
    [ ! -f "$target" ] && target="$tmpd/NOTE/NOTE.ms"   && fmt=ms
    [ ! -f "$target" ] && target="$tmpd/NOTE/NOTE.mm"   && fmt=mm
    [ ! -f "$target" ] && target="$tmpd/NOTE/NOTE.mom"  && fmt=mom
    [ ! -f "$target" ] && echo "note: NOTE file not found within the archive" >&2 && exit 4
    [ -n "$textonly" ] && fmt=txt

    # Perform string substitutions, update access time
    strsub "$notedir/$1" "$target"
    touch -ac -- "$notedir/$1"

    case "$fmt" in
        txt)
            if [ $stdout ]; then
                cat -- "$target"
            else
                cp -- "$target" "$output"
            fi
            ;;
        md)
            if [ $stdout ]; then
                printf "%s" "$HTML_MD_STYLE"
                md2html --github -- "$target"
            else
                printf "%s" "$HTML_MD_STYLE" >"$output"
                md2html --github -- "$target" >>"$output"
            fi
            ;;
        adoc)
            if [ $stdout ]; then
                asciidoctor $ASCIIDOCTOR_OPTS -o - -- "$target"
            else
                asciidoctor $ASCIIDOCTOR_OPTS -o "$output" -- "$target"
            fi
            ;;
        rnd)
            if [ $stdout ]; then
                ntmake "$target" -mrnd
            else
                ntmake "$target" -mrnd >"$output"
            fi
            ;;
        ms)
            if [ $stdout ]; then
                ntmake "$target" -ms
            else
                ntmake "$target" -ms >"$output"
            fi
            ;;
        mm)
            if [ $stdout ]; then
                ntmake "$target" -mm
            else
                ntmake "$target" -mm >"$output"
            fi
            ;;
        mom)
            if [ $stdout ]; then
                pdfmom -k -e -p -t "$target"
            else
                pdfmom -k -e -p -t "$target" >"$output"
            fi
            ;;
        *)
            printf "note: unknown note format \"%s\"\n" "$fmt" >&2
    esac
    find "$tmpd" -type f -exec shred -x '{}' \;
    rm -rf -- "$tmpd"
}

edit=
textonly=
output=
force_dmenu=
force_fzf=
while true; do
    case "$1" in
        -h|--help) help ; exit ; shift ;;
        -e|--edit) edit=1 ; shift ;;
        -t|--textonly) textonly=1 ; shift ;;
        -o|--output)
            if [ -z "$2" ]; then
                echo "note: output filename needed" >&2
                exit 2
            else
                output="$2"
                shift 2
            fi ;;
        --dmenu) force_dmenu=1 ; shift ;;
        --fzf)   force_fzf=1   ; shift ;;
        --) shift ; break ;;
        *) break ;;
    esac
done
[ -n "$force_dmenu" ] && [ -n "$force_fzf" ] && {
    echo 'note: --fzf and --dmenu are mutually exclusive' >&2
    exit 5
}

[ ! -d "$notedir" ] && echo "note: notes dir not found" >&2 && exit 1

# Check if shell is interactive
if [ -n "$force_dmenu" ]; then
    interactive=
elif [ -n "$force_fzf" ]; then
    interactive=1
else
    interactive=
    [ -t 0 ] && interactive=1
fi

if [ $# -eq 0 ]; then
    if [ -n "$output" ]; then # Output existing note

        [ -n "$edit" ] && echo "note: illegal use of --edit option" >&2 && exit 2

        # For interactive shells use fzf, otherwise use dmenu.
        prompt="Output Note:"
        if [ -n "$interactive" ]; then
            note="$(cd "$notedir" && find . -type f \! -path '\./\.*' -exec realpath --relative-to "$notedir" '{}' \; \
                | fzf --no-sort --no-multi --prompt "$prompt ")"
        else
            note="$(cd "$notedir" && find . -type f \! -path '\./\.*' -exec realpath --relative-to "$notedir" '{}' \; \
                | dmenu -F -l 5 -p "$prompt")"
        fi

        [ -z "$note" ] && exit
        output "$note" "$output"

    else # View/edit existing note

        # For interactive shells use fzf, otherwise use dmenu.
        if [ -z "$edit" ]; then prompt="View Note:"; else prompt="Edit Note:"; fi
        if [ -n "$interactive" ]; then
            note="$(cd -- "$notedir" && find . -type f \! -path '\./\.*' -exec realpath --relative-to "$notedir" '{}' \; \
                | fzf --no-sort --no-multi --prompt "$prompt ")"
        else
            note="$(cd -- "$notedir" && find . -type f \! -path '\./\.*' -exec realpath --relative-to "$notedir" '{}' \; \
                | dmenu -F -l 5 -p "$prompt")"
        fi

        [ -z "$note" ] && exit
        if [ -z "$edit" ]; then
            view "$note"
        else
            edit "$note"
        fi
    fi

# Create new note
else
    [ -n "$textonly" ] && echo "note: illegal use of --textonly option" >&2 && exit 2
    [ -n "$edit" ] && echo "note: illegal use of --edit option" >&2 && exit 2
    [ -n "$output" ] && echo "note: illegal use of --output option" >&2 && exit 2
    fname="$(printf "%s" "$*" | tr ' ' '-')"
    [ -z "$(basename -- "$fname")" ] && echo "note: cannot create a note with empty filename" >&2 && exit 2

    ext=
    case "$fname" in
        *.md)   ext=.md   ;;
        *.adoc) ext=.adoc ;;
        *.rnd)  ext=.rnd  ;;
        *.ms)   ext=.ms   ;;
        *.mm)   ext=.mm   ;;
        *.mom)  ext=.mom  ;;
        *.txt)  ext=.txt  ;;
        *)      ext=.txt fname="$fname$ext" ;;
    esac
    [ -e "$notedir/$fname" ] && echo "note: a note with the same name already exists" >&2 && exit
    create "$fname" "$ext"
fi
