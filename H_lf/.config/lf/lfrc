# Set ZSH
# I need the read -q command
set shell zsh

# Enable icons
set icons

# Define file separator
set ifs "\n"

# Trash and delete files
map x :trash
map X :delete
cmd trash ${{
    set -f
    clear
    echo -e "$fx\\n"
    echo -n "move to trash? [y/N] "
    read -q ans
    [ $ans = "y" ] && mv $fx "$HOME/.local/share/Trash/files"
}} 

# Alternate selection bindings
map v :{{
    toggle
    up
}}
map <c-v> :invert

# Fuzzy Find
cmd fuzzy-find ${{
    match="$(find . -maxdepth 1 | fzf --bind=ctrl-d:half-page-down,ctrl-u:half-page-up)"
    if [ -n $match ]; then
        [ "$(expr "$match" : "^\..*")" -ne 0 ] && lf -remote "send $id set hidden"
        lf -remote "send $id select '$match'"
    fi
}}
cmd fuzzy-find-recursive ${{
    match="$(find . | fzf --bind=ctrl-d:half-page-down,ctrl-u:half-page-up)"
    if [ -n $match ]; then
        [ "$(expr "$match" : "^\..*")" -ne 0 ] && lf -remote "send $id set hidden"
        lf -remote "send $id cd '$(dirname "$match")'"
        lf -remote "send $id select '$(basename "$match")'"
    fi
}}
map o :fuzzy-find
map O :fuzzy-find-recursive

# Put to background
map <c-z> $ kill -STOP $PPID

# Bulk rename
cmd bulk-rename ${{
    old="$(mktemp)"
    new="$(mktemp)"
    [ -z $fs ] && fs="$(ls)"
    printf "$fs\n" > "$old"
    printf "$fs\n" > "$new"
    "$EDITOR" "$new"
    [ "$(cat "$new" | wc -l)" -ne "$(cat "$old" | wc -l)" ] && exit
    paste "$old" "$new" | while read names; do
        src="$(printf "$names" | cut -f1)"
        dst="$(printf "$names" | cut -f2)"
        [ "$src" = "$dst" ] && continue
        [ -e "$dst" ] && continue
        mv "$src" "$dst"
    done
    rm "$old" "$new"
    lf -remote "send $id unselect"
}}
map R :bulk-rename

# Print file information
cmd info !{{
    clear
    printf "\n Computing..."
    CONTENT="$(echo "$fx" | fls)"
    clear
    printf "\n$CONTENT"
}}
map I :info

# Generate directory shortcuts from jumplist
map c
map cd<enter> :cd ~
map cd/ :cd /
$"$HOME/.scripts/genlfjmp"
:source "/tmp/genlfjmp_maps"
